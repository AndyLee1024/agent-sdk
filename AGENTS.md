本仓库的 agent 行为必须遵守以下规则。凡出现“必须/禁止”均不可协商。规则目标：KISS、避免 God Object/Blob、控制 self 状态耦合、保证小步可回滚。

────────────────────────────────────────
## 1) 工作方式（硬规则）

1. 先方案后编码：任何任务先输出 2–3 个方案（Quick / Balanced / Long-term）+ 风险 + 需要我回答的问题；我明确批准前，禁止写/改任何代码。
2. 不清楚就问：遇到歧义/缺信息/不确定点，必须先问我，禁止猜。
3. 小步变更：一次只做一个小步骤（优先 ≤3 个文件、≤200 行净新增，不含格式化）。超过就拆步，每步可运行/可回滚。
4. 不生成总结文档：除非我明确要求，否则不要新增“总结/报告/说明类新文件”。

────────────────────────────────────────
## 2) Anti-God-Object / Anti-Blob（硬护栏）

1. 单文件上限：任何改动后，任何文件不得 > 700 LOC。
   - 若目标文件已 >700：本次禁止净增行数；只能抽取/拆分/重构使其下降或至少不增长。
2. self 状态耦合上限：单个类的“可变 self.* 字段”不得 > 8；方法数不得 > 12。
   - 若接近/已超：禁止继续往该类加字段/加方法，必须先拆分或外置状态。
3. 显式状态模型：跨功能共享的运行态只允许进入 State；配置只允许进入 Config；禁止把临时状态塞进 self.*。
4. 触发任一上限时（700 LOC / self>8 / methods>12）：立刻停止编码，输出《拆分方案》（不写代码），包含：
   - 新文件/模块清单 + 各自职责边界
   - State/Config 归属与数据流（显式入参/出参）
   - 分步迁移计划（每步小、可运行、可回滚）
   - 可能的连锁影响与回归风险 + 缓解点（测试/适配/隔离）

────────────────────────────────────────
## 3) 设计模式提点器（超极简 6 条）

规则：命中触发条件时，你必须在方案里“采用某模式”或“明确说明不采用的理由”，并给出最小落地形态（文件/接口/类）。一次变更优先只用 1 个主模式，避免叠模式。

1) 分支爆炸（大量 if/elif 按 type/provider/mode 分派）→ Strategy  
   最小形态：`Protocol` + `strategies/` + 单一选择点（registry/工厂函数）。

2) 很多动作/命令（CLI/TUI 命令可扩展）→ Command  
   最小形态：`commands/` + `Command.execute(ctx)` + dispatcher 映射。

3) 行为依赖状态（很多 flag/self 状态驱动流程）→ State  
   最小形态：显式 State 枚举/数据结构 + transition/handler 映射，禁止隐式散落的 flags。

4) 外部依赖污染（prompt_toolkit/HTTP/DB/FS 到处 import、难测）→ Adapter（Ports & Adapters）  
   最小形态：`ports.py`（Protocols）+ `adapters/`（具体实现）+ core 仅依赖 ports。

5) 核心类越来越胖（编排+业务+IO 混一起）→ Facade（薄壳）+ Extract Services  
   最小形态：保留薄 `App/Facade` 只做 wiring；业务逻辑搬到 `services/`（尽量无状态）+ 显式 State/Config。

6) 长流程串联（一个函数很多步骤想插拔/重排）→ Pipeline  
   最小形态：`stages: list[Stage]`（函数/对象）+ `run(ctx)->ctx`，每步单一职责。

方案输出必须包含两行：
- 命中触发：上述 6 条里命中了哪些（如无命中写“无”）
- 模式决策：采用的主模式（或不采用原因）+ 最小落地形态（文件/接口草图）

────────────────────────────────────────
## 4) Python 工程规则（硬规则）

1. 字符串：必须使用 f-string；禁止 format/% 拼接（除非库接口要求）。
2. 日志：必须使用 logging；禁止 print。
3. 运行：必须用 `uv run python xxx.py` 运行脚本。
4. 依赖：必须用 `uv add 包名` 安装依赖。
5. 配置：禁止硬编码路径/配置/token；必须使用环境变量或配置文件；读取配置必须集中在 Config 构建处，业务逻辑不得到处读 env。
6. 风格：遵循 PEP 8；使用 black 格式化；新增复杂逻辑优先抽到可测试的纯函数/小模块。

────────────────────────────────────────
## 5) Prompt_toolkit / TUI 铁律（硬规则）

1. 禁止 History TUI：聊天历史只写入终端 scrollback；UI layout 只允许底部输入/补全/状态栏；历史输出唯一通道是 `run_in_terminal(...)` 追加。
2. 禁止承载历史的 multiline read-only 组件：
   - 禁止 `TextArea(multiline=True, read_only=True)` 或任何 messages/history/chat 命名的 Window/TextArea/FormattedTextControl。
3. 禁止回写已输出到 scrollback 的历史行：只能追加，不可修改。
4. 涉及 prompt_toolkit：必须使用 context7 mcp 的 `resolve-library-id` + `query-docs` 校验用法；查不到关键文档就停下问我/说明不确定点。

────────────────────────────────────────
## 6) 排查/修复（必须工程化）

当我要求“排查/修 bug/修复/重构”时，你必须先输出：
- 根因（为什么会发生）
- 影响面（哪些模块/调用方/行为会受影响）
- 连锁风险（可能破坏什么）
- 缓解与回滚（测试点/隔离/适配/渐进迁移）
然后等我确认方案再编码。
